// schema.prisma
generator client {
  provider = "prisma-client-js"
}

generator client_edge {
  provider = "prisma-client-js"
  output   = "./node_modules/@prisma/client/edge"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id              String   @id @default(uuid())
  email           String   @unique
  name            String
  bio             String
  password        String
  blogs           Blog[]   // blogs written by user
  imageLink       String
  updatedCount    Int      @default(0)
  lastUpdateDate  DateTime?
  createdAt       DateTime @default(now())

  // Upvotes relation (blogs)
  upvotedBlogs    Blog[]   @relation("Upvotes")

  // Followers/following
  followers       Follower[] @relation("FollowedUser")
  following       Follower[] @relation("FollowingUser")

  // Profile views relations
  profileViewers  ProfileView[] @relation("ViewedUserRelation") // people who viewed this user
  profilesViewed  ProfileView[] @relation("ViewerRelation")     // profiles this user viewed

  profileViews    Int      @default(0) // total views count

  // --- comments & comment likes (implicit many-to-many) ---
  comments        Comment[]     @relation("AuthorComments") // comments authored by user
  likedComments   Comment[]     @relation("CommentLikes")  // comments this user liked (implicit join table)
}

model Blog {
  id        String  @id @default(uuid())
  title     String
  content   String
  published Boolean @default(false)
  upvotes   Int      @default(0)         // upvote count for blog
  author    User    @relation(fields: [authorId], references: [id])
  authorId  String
  tags      Tag[]   @relation("BlogTags")
  createdAt DateTime @default(now())
  imageLink String  @default("https://upload.wikimedia.org/wikipedia/commons/a/a3/Image-not-found.png?20210521171500")
  upvotedBy User[]  @relation("Upvotes")

  // comments on this blog (top-level only)
  comments  Comment[]
}

model Tag {
  id    String  @id @default(uuid())    // unique ID
  name  String  @unique                 // tag name like 'cricket', 'coding'
  blogs Blog[]  @relation("BlogTags")   // link to many blogs
}

model Follower {
  id            String   @id @default(uuid())
  follower      User     @relation("FollowingUser", fields: [followerId], references: [id])
  followerId    String
  followed      User     @relation("FollowedUser", fields: [followedId], references: [id])
  followedId    String
  createdAt     DateTime @default(now())

  @@unique([followerId, followedId]) // prevent duplicate follows
}

model ProfileView {
  id           String   @id @default(uuid())

  viewer       User     @relation("ViewerRelation", fields: [viewerId], references: [id])
  viewerId     String

  viewedUser   User     @relation("ViewedUserRelation", fields: [viewedUserId], references: [id])
  viewedUserId String

  viewedAt     DateTime @default(now())
}

/*
  Comments system (Option A: implicit many-to-many for comment likes)
  - Comment: top-level comments only (no parentId)
  - likedComments in User and likedBy in Comment form an implicit join table managed by Prisma
  - likesCount is denormalized for faster reads; update it transactionally when liking/unliking
*/
model Comment {
  id         String    @id @default(uuid())
  blog       Blog      @relation(fields: [blogId], references: [id])
  blogId     String

  author     User      @relation("AuthorComments", fields: [authorId], references: [id])
  authorId   String

  content    String

  createdAt  DateTime  @default(now()) // full timestamp; format to date-only or relative in UI
  edited     Boolean   @default(false)
  editedAt   DateTime?

  // implicit many-to-many: users who liked the comment
  likedBy    User[]    @relation("CommentLikes")

  // optional denormalized count for faster reads (keep in sync in app logic)
  likesCount Int       @default(0)

  @@index([blogId])
  @@index([createdAt])
}
